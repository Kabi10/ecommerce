# Cursor Rules

## ‚ö†Ô∏è MANDATORY PRE-IMPLEMENTATION CHECKLIST ‚ö†Ô∏è
STOP! Before writing ANY code or suggesting ANY changes:

1. üîç SEARCH FIRST:
   ```bash
   # REQUIRED: Run these searches and document results
   grep_search for functionality
   file_search for similar files
   list_dir in relevant directories
   ```

2. üìù DOCUMENT FINDINGS:
   ```markdown
   # REQUIRED: Fill this out
   ## Existing Files Found:
   - [List all relevant files found]
   
   ## Existing Functionality:
   - [Describe what already exists]
   
   ## Gaps Identified:
   - [List what's missing or needs enhancement]
   
   ## Proposed Approach:
   - [ ] Enhance existing code
   - [ ] Create new files (requires justification)
   - [ ] Refactor existing code
   ```

3. ‚úã WAIT FOR APPROVAL:
   - Present findings to user
   - Get explicit approval for approach
   - Never proceed with new files if similar functionality exists

‚ùå IF YOU SKIP THIS CHECKLIST, YOU ARE VIOLATING THE MOST IMPORTANT RULE ‚ùå

## Instructions

- Record fixes for mistakes or corrections to avoid repetition in the `Lessons` section.
- Organize thoughts and plan steps before starting a task in the `Scratchpad` section.
- Clear old tasks if necessary.
- Use todo markers for progress tracking:
  - `[X]` Completed tasks
  - `[ ]` Pending tasks
- Update Scratchpad after completing subtasks.
- Reflect and plan after milestones for better task management.
- Always refer to Scratchpad before planning the next step.
- ALWAYS CHECK FOR EXISTING FILES BEFORE CREATING NEW ONES TO AVOID DUPLICATES.

## Lessons

1. Use `npx shadcn@latest add [component]` instead of `npx shadcn-ui@latest add [component]` when installing Shadcn UI components.
2. In Next.js 14+, page props params must be typed as a Promise.
3. Use `const session = await auth()` instead of `const session = await getServerSession(authOptions)` for Next.js authentication.
4. When importing `useRouter` from 'next/navigation', the component must be marked as a client component using the `'use client'` directive.
5. Always check for existing files and functionality before creating new ones to avoid duplication.
6. When using Prisma's Decimal type with TypeScript, convert it to a number using `Number(price)` to match the expected type.
7. When dealing with nullable fields from the database, update the TypeScript interfaces to reflect this with union types (e.g., `string | null`).
8. In Next.js 15, components using `useSearchParams()` must be:
   - Marked with `'use client'`
   - Wrapped in a Suspense boundary
   - Preferably isolated in their own component for better control
9. For client-side navigation components that need search params, prefer passing them as props from the server component instead of using `useSearchParams()` directly.
10. When using dynamic imports with `next/dynamic`, set `ssr: false` for client-only components that use browser APIs.
11. When using client-side state (like Zustand stores) in components that can be server-rendered:
    - Extract client-side state display into separate client components
    - Use dynamic imports with `ssr: false` for components that depend on client state
    - Provide loading fallbacks that match the component's structure
    - Wrap client components in Suspense boundaries
12. Keep layouts simple and avoid duplicate UI patterns:
    - Layout components (`layout.tsx`) should focus on structural elements and shared UI
    - Page-specific UI elements should live in the page component (`page.tsx`)
    - Avoid implementing the same functionality in both layout and page components
    - When in doubt, prefer implementing UI elements in the page component for better maintainability
13. When working with client components that use search parameters:
    - Create a separate content component for the actual functionality
    - Create a loading fallback that matches the structure of the content
    - Use Suspense to wrap the content component
    - Keep state management within the content component
14. For form components with loading states:
    - Handle loading states within the component using local state
    - Show appropriate loading indicators during async operations
    - Disable form inputs and buttons during submission
    - Provide clear feedback about the operation status
15. When implementing filters and search:
    - Use URL search parameters to maintain state
    - Implement debouncing for search inputs
    - Create separate components for different filter types
    - Use appropriate loading states for each filter component
16. ALWAYS check for existing implementations before creating new files:
    - Use grep_search or file_search to look for similar file names
    - Search for related functionality in the codebase
    - Check both the exact path and alternative locations
    - If similar functionality exists, either enhance it or clearly document why a new implementation is needed
    - Document the search process in the scratchpad before implementing new features
17. NEVER skip the pre-implementation checklist:
    - Skipping the checklist leads to duplicate code
    - Duplicate code increases maintenance burden
    - Duplicate code creates confusion about which implementation to use
    - Duplicate code wastes time that could be spent enhancing existing features
    - Always document your search process and findings before suggesting any changes
18. Maintain consistent page layouts across sections:
    - Use consistent padding (e.g., p-6)
    - Use consistent header spacing (e.g., mb-8)
    - Use consistent heading styles
    - Use consistent description text styles
    - Follow the established pattern:
      ```tsx
      <div className="p-6">
        <div className="mb-8">
          <h1 className="text-3xl font-bold">Page Title</h1>
          <p className="text-muted-foreground">Page description</p>
        </div>
        <Suspense fallback={<Skeleton />}>
          <Content />
        </Suspense>
      </div>
      ```
19. Handle authentication and authorization properly:
    - Use middleware for protecting routes
    - Include callback URLs for better UX
    - Keep auth logic out of layout components
    - Use role-based access control
    - Handle auth state loading properly
20. Implement proper loading states:
    - Create skeleton components that match content structure
    - Use Suspense boundaries effectively
    - Show loading indicators for async operations
    - Maintain layout stability during loading

## Build Error Prevention Rules

1. Next.js Configuration Best Practices:
   - Keep `next.config.js` clean and minimal
   - Use `typescript.ignoreBuildErrors` and `eslint.ignoreDuringBuilds` only temporarily
   - Configure proper image domains in `remotePatterns`
   - Set appropriate `experimental` features carefully

2. Client Component Rules:
   - Always use 'use client' directive for components with hooks
   - Wrap client components in Suspense boundaries
   - Use dynamic imports for heavy client-side components
   - Provide loading states for all async operations

3. Build Process Requirements:
   - Run `npm run clean` before builds
   - Check for type errors with `tsc --noEmit`
   - Monitor build logs for warnings
   - Keep dependencies updated weekly

4. Error Resolution Steps:
   - Check type definitions first
   - Verify import paths
   - Ensure proper Suspense boundaries
   - Validate environment variables
   - Review API endpoint configurations

5. Performance Optimization Rules:
   - Use dynamic imports for large components
   - Implement proper code splitting
   - Optimize images and assets
   - Monitor bundle sizes

6. SEO and Sitemap Rules:
   - Maintain proper next-sitemap.config.js
   - Update meta tags and descriptions
   - Configure robots.txt appropriately
   - Exclude sensitive routes

7. Development Workflow:
   - Use proper TypeScript types
   - Implement error boundaries
   - Add loading states
   - Test in both development and production

8. Authentication and API Rules:
   - Use proper error handling
   - Implement proper session management
   - Handle edge cases and loading states
   - Validate all user inputs

9. Required Scripts in package.json:
   ```json
   {
     "scripts": {
       "dev": "next dev",
       "build": "prisma generate && next build",
       "postbuild": "next-sitemap",
       "start": "next start",
       "lint": "next lint",
       "clean": "rimraf .next out",
       "prebuild": "npm run clean",
       "type-check": "tsc --noEmit"
     }
   }
   ```

10. Required Development Dependencies:
    - rimraf (for cleaning build artifacts)
    - next-sitemap (for sitemap generation)
    - typescript (for type checking)
    - eslint and related plugins

## Critical Standards

### Version Control Standards
- Never commit directly to main/master
- Branch naming: `feature/`, `fix/`, `refactor/`, `docs/` prefixes
- Commit messages must reference task/issue numbers
- Squash commits before merging to main
- Delete branches after merging

### Rollback Procedures
- Keep deployment artifacts for last 3 successful builds
- Document rollback commands in deployment scripts
- Maintain database migration reversions
- Keep configuration backups
- Test rollback procedures monthly

### Performance Budgets
- Page Load: < 3s on 4G
- First Contentful Paint: < 1.5s
- Bundle Size: < 200KB initial JS
- API Response: < 300ms
- Image Optimization: WebP/AVIF with fallbacks
- Core Web Vitals minimum:
  - LCP: < 2.5s
  - FID: < 100ms
  - CLS: < 0.1

### Dependency Management
- Weekly security audit: `npm audit`
- Monthly dependency updates
- Keep lockfile clean (no duplicate packages)
- Document breaking changes
- Test suite must pass after updates
- Update order: 
  1. Security patches
  2. Core dependencies (Next.js, React)
  3. UI components
  4. Dev dependencies

### Testing Requirements by Feature Type
1. UI Components:
   - Unit tests for logic
   - Snapshot tests for rendering
   - Accessibility tests
   - Browser compatibility tests

2. Forms:
   - Validation tests
   - Error state tests
   - Submit handling tests
   - Loading state tests

3. API Endpoints:
   - Input validation tests
   - Authentication tests
   - Error handling tests
   - Rate limiting tests
   - Integration tests

4. Data Mutations:
   - Transaction tests
   - Rollback tests
   - Constraint tests
   - Race condition tests

5. Authentication:
   - Session handling tests
   - Permission tests
   - Token validation tests
   - OAuth flow tests

### Environment-Specific Checks
#### Development
- Hot reload working
- TypeScript watching
- ESLint auto-fixing
- Test runner in watch mode
- Local DB migrations
- ENV variables validated

#### Staging
- Production build test
- Full test suite
- Load testing
- Integration testing
- E2E testing
- DB migration dry run

#### Production
- Zero-downtime deployment
- Backup verification
- SSL/TLS check
- CDN purge
- DNS propagation
- Health check endpoints
- Monitoring active
- Alert system ready

### Automated Testing Pipeline
```yaml
# Example GitHub Actions workflow structure
name: CI
on: [push, pull_request]
jobs:
  validate:
    - lint
    - type-check
    - unit-tests
    - build
  integrate:
    - e2e-tests
    - api-tests
    - performance-tests
  security:
    - dependency-audit
    - security-scan
    - license-check
  deploy:
    - environment-check
    - backup
    - deploy
    - health-check
    - rollback-ready
```

### Component Organization Standards
1. Page Components:
   - Must be server components by default
   - Should focus on layout and data fetching
   - Should use Suspense for loading states
   - Should implement proper metadata
   Example:
   ```tsx
   export const metadata = {
     title: "Page Title",
     description: "Page description"
   }

   export default function Page() {
     return (
       <div className="p-6">
         <div className="mb-8">
           <h1 className="text-3xl font-bold">Title</h1>
           <p className="text-muted-foreground">Description</p>
         </div>
         <Suspense fallback={<Skeleton />}>
           <Content />
         </Suspense>
       </div>
     )
   }
   ```

2. Content Components:
   - Should be client components if they need interactivity
   - Should handle their own state management
   - Should implement proper loading states
   - Should be wrapped in Suspense boundaries

3. Layout Components:
   - Should focus on structural elements
   - Should avoid implementing page-specific logic
   - Should handle navigation and shared UI
   - Should implement proper auth protection

4. UI Components:
   - Should be reusable across different contexts
   - Should implement proper TypeScript types
   - Should handle all possible states (loading, error, empty)
   - Should follow accessibility guidelines

### File Structure Standards
```
app/
  ‚îú‚îÄ‚îÄ (routes)/
  ‚îÇ   ‚îú‚îÄ‚îÄ page.tsx
  ‚îÇ   ‚îú‚îÄ‚îÄ layout.tsx
  ‚îÇ   ‚îî‚îÄ‚îÄ loading.tsx
  ‚îú‚îÄ‚îÄ api/
  ‚îÇ   ‚îî‚îÄ‚îÄ route.ts
components/
  ‚îú‚îÄ‚îÄ ui/
  ‚îÇ   ‚îî‚îÄ‚îÄ [shadcn-components]
  ‚îú‚îÄ‚îÄ [feature]/
  ‚îÇ   ‚îú‚îÄ‚îÄ component.tsx
  ‚îÇ   ‚îî‚îÄ‚îÄ loading.tsx
  ‚îî‚îÄ‚îÄ skeletons/
lib/
  ‚îú‚îÄ‚îÄ utils.ts
  ‚îî‚îÄ‚îÄ constants.ts
types/
  ‚îî‚îÄ‚îÄ index.ts
```

## Scratchpad

### Phase 1: Project Setup and Configuration
[X] 1.1. Initial Setup
    [X] Create new Next.js 15 project with TypeScript
    [X] Configure ESLint and Prettier
    [X] Set up project structure and folders
    [X] Initialize Git repository

[X] 1.2. Dependencies Installation
    [X] Install and configure Shadcn UI
    [X] Set up Lucide icons
    [X] Install remaining core dependencies
        [X] Add Zod for validation
        [X] Add Zustand for state management
        [X] Add Recharts for analytics
        [X] Add Resend for emails
        [X] Add Uploadthing for file uploads
    [X] Configure Tailwind CSS
        [X] Add remaining Tailwind plugins
        [X] Configure theme extensions

[X] 1.3. Database and Authentication Setup
    [X] Set up PostgreSQL database
    [X] Configure Prisma and create initial schema
    [X] Implement NextAuth.js beta for authentication
    [X] Set up email service with Resend

üìã Phase 1 CI/Error Checks:
  [X] Run type check: npm run type-check
  [X] Run linting: npm run lint
  [X] Verify all dependencies installed: npm install
  [X] Test build: npm run build
  [X] Check for environment variables
  [X] Verify database connection
  [X] Test authentication flow

### Phase 2: Core Features Development
[X] 2.1. Products Catalog
    [X] Products listing page with filters and search
        [X] Implement product grid layout
        [X] Add search functionality
        [X] Add category filtering
        [X] Add price range filtering
        [X] Implement pagination with proper Suspense boundaries
        [X] Add loading skeletons
    [X] Product detail pages with image gallery
        [X] Create product detail layout
        [X] Implement image gallery
        [X] Add product information section
        [X] Handle decimal price formatting
    [X] Reviews and ratings section
        [X] Display review list
        [X] Show average rating
        [X] Handle nullable review fields
        [X] Add star rating display
    [X] Related products section
        [X] Fetch related products by category
        [X] Display related products grid
        [X] Add hover effects and transitions

üìã Products Feature CI/Error Checks:
  [X] Verify all API endpoints
  [X] Test pagination edge cases
  [X] Check image optimization
  [X] Validate search functionality
  [X] Test filter combinations
  [X] Verify responsive layout
  [X] Run build and check bundle size

[X] 2.2. Shopping Cart System
    [X] Create cart store with Zustand
    [X] Implement add/remove functionality
    [X] Cart persistence
    [X] Quantity management
    [X] Cart total calculations

üìã Cart Feature CI/Error Checks:
  [X] Test cart persistence
  [X] Verify price calculations
  [X] Check state management
  [X] Test localStorage fallback
  [X] Verify cart sync across tabs
  [X] Run build and check bundle size

[ ] 2.3. User Authentication
    [X] Sign up/login flows
    [X] User roles (admin, customer)
    [X] Password reset functionality
        [X] Create forgot password page
        [X] Implement forgot password API with JWT
        [X] Create reset password page
        [X] Implement reset password API with JWT verification
        [X] Add development mode token logging
    [X] OAuth providers integration
        [X] Configure GitHub OAuth
        [X] Configure Google OAuth
        [X] Update sign-in page with provider buttons
        [X] Handle OAuth callbacks and user creation
    [X] Authentication Improvements
        [X] Switch from Prisma adapter to JWT strategy
        [X] Remove database session storage
        [X] Implement stateless password reset
        [X] Update schema to remove reset token fields

üìã Authentication CI/Error Checks:
  [X] Test all auth flows
      - Credentials provider working
      - JWT strategy implemented
      - Session handling verified
  [X] Verify JWT handling
      - Custom JWT interface defined
      - Token transformation working
      - Session synchronization complete
  [X] Check OAuth providers
      - Credentials provider configured
      - JWT strategy preferred over database sessions
  [X] Test password reset flow
      - Stateless JWT-based reset implemented
      - Email service configured with Resend
  [X] Verify role-based access
      - Admin routes protected
      - Role checks in middleware
      - Session includes role information
  [X] Check session handling
      - JWT-based sessions working
      - Token refresh implemented
      - Session data properly typed
  [X] Run security audit
      - Password hashing with bcrypt
      - Protected routes configured
      - Error handling implemented
  [X] Test rate limiting
      - API routes protected
      - Auth endpoints secured
  [X] Run build and check bundle size
      - Clean build passing
      - Types checking passed
      - No auth-related errors

### Phase 3: Admin Dashboard Development
[ ] 3.1. Admin Panel Setup
    [X] Create admin layout
        - Basic layout implemented
        - Navigation structure created
        - Responsive design in place
    [X] Implement admin authentication
        - Role-based access control
        - JWT verification
        - Protected routes
    [X] Set up admin routes protection
        - Middleware configured
        - Role checks implemented
        - Redirect to login
    [X] Create admin navigation
        - Sidebar navigation
        - Top navigation bar
        - Mobile responsive menu

[ ] 3.2. Dashboard Analytics
    [X] Key Metrics Cards
        [X] Total revenue widget
            - Real-time data
            - Change percentage
            - Animated display
        [X] Total orders widget
            - Order count
            - Change tracking
            - Trend indicator
        [X] Total customers widget
            - Customer growth
            - Change percentage
            - Visual feedback
        [X] Average order value widget
            - Calculated metrics
            - Trend analysis
            - Performance indicator
    [X] Sales Analytics
        [X] Revenue Chart
            - Daily revenue tracking
            - Order count overlay
            - Interactive tooltips
            - Responsive design
        [X] Order Statistics
            - Status distribution
            - Visual breakdown
            - Real-time updates
            - Dark mode support
    [X] Build Test Results
        [X] Configuration Updates
            - Updated all config files to ES modules
            - Fixed PostCSS configuration
            - Updated sitemap config
            - Added missing dependencies
        [X] Build Metrics
            - First Load JS: 118 kB
            - Admin Page Size: 144 kB
            - Middleware Size: 32.5 kB
        [X] Performance
            - Static pages optimized
            - Dynamic routes configured
            - API routes protected
        [X] Dependencies
            - Added framer-motion for animations
            - Added next-themes for dark mode
            - All dependencies up to date
    [X] Recent Orders Table
        [X] Order list component
        [X] Status indicators
        [X] Customer details
        [X] Action buttons

üìã Recent Orders Table CI/Error Checks:
  [X] Run type check: npm run type-check
  [X] Run build: npm run build
  [X] Check bundle size: Admin page size is 153 kB
  [X] Verify component structure
  [X] Test responsive design
  [X] Validate data display
  [X] Check loading states
  [X] Verify action buttons
  [X] Test empty state handling

    [X] Low Stock Alerts
        [X] Alert component
        [X] Stock level indicators
        [X] Reorder suggestions
        [X] Action buttons

üìã Low Stock Alerts CI/Error Checks:
  [X] Run type check: npm run type-check
  [X] Run build: npm run build
  [X] Check bundle size: Admin page size is 154 kB
  [X] Verify component structure
  [X] Test responsive design
  [X] Validate data display
  [X] Check loading states
  [X] Verify action buttons
  [X] Test empty state handling
  [X] Verify reorder functionality

[ ] 3.3. Product Management Interface
    [ ] Create product listing interface
    [ ] Implement bulk operations
    [ ] Add product variant management
    [ ] Create inventory management system

[ ] 3.4. Order Management System
    [ ] Create order tracking interface
    [ ] Implement order status management
    [ ] Add order filtering and search
    [ ] Create order reports

### Phase 4: User Features and Experience
[ ] 4.1. User Dashboard
    [ ] Create user profile management
    [ ] Implement order history
    [ ] Add wishlist functionality
    [ ] Create address management

[ ] 4.2. Product Features
    [ ] Add ability to write reviews
    [ ] Implement product sharing
    [ ] Create product recommendations

### Phase 5: Advanced Features
[X] 5.1. Search and Filter
    [X] Implement advanced search
    [X] Add faceted filtering
    [X] Create price range filter
    [X] Implement sorting options

[ ] 5.2. Performance Optimization
    [ ] Implement image optimization
    [ ] Add lazy loading
    [ ] Configure caching
    [ ] Optimize API routes

[ ] 5.3. SEO and Marketing
    [ ] Implement SEO best practices
    [ ] Add sitemap generation
    [ ] Create meta tags
    [ ] Set up schema markup

### Phase 6: Testing and Deployment
[ ] 6.1. Testing
    [ ] Write unit tests
    [ ] Implement integration tests
    [ ] Perform E2E testing
    [ ] Conduct security testing

[ ] 6.2. Deployment
    [ ] Set up CI/CD pipeline
    [ ] Configure production environment
    [ ] Deploy to production
    [ ] Monitor performance

### Phase 7: Post-Launch
[ ] 7.1. Monitoring and Maintenance
    [ ] Set up error tracking
    [ ] Implement analytics
    [ ] Create backup system
    [ ] Monitor performance metrics

[ ] 7.2. Documentation
    [ ] Create API documentation
    [ ] Write user documentation
    [ ] Document admin processes
    [ ] Create maintenance guides

### Standard CI/Error Check Template (Copy for new phases):
```markdown
üìã Feature CI/Error Checks:
  [ ] Run type check: npm run type-check
  [ ] Run linting: npm run lint
  [ ] Test build: npm run build
  [ ] Check bundle size
  [ ] Verify API endpoints
  [ ] Test error handling
  [ ] Check performance
  [ ] Validate responsive design
  [ ] Test accessibility
  [ ] Run security checks
```

## File Creation Checklist
Before creating any new file or component:
1. Search for existing files with similar names:
   ```bash
   # Example searches
   grep -r "componentName" .
   find . -name "*componentName*.tsx"
   ```
2. Search for similar functionality:
   - Check obvious locations (e.g., components/, app/)
   - Search for related terms in the codebase
   - Look for similar features in different directories
3. If similar exists:
   - Document why enhancement/replacement is needed
   - Get explicit approval for creating a new version
   - Ensure no functionality is lost in the process
4. Document the search process:
   - What terms were searched
   - What files were found
   - Why existing files were not suitable
   - Why a new file is necessary